{"basePath":"/v1","definitions":{"Bundle":{"properties":{"uuid":{"description":"Bundle unique ID","pattern":"[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}","type":"string"},"versions":{"items":{"description":"Timestamp of bundle creation in DSS_VERSION format.","format":"DSS_VERSION","type":"string"},"type":"array"}},"required":["uuid","versions"],"type":"object"},"Collection":{"properties":{"contents":{"description":"A list of objects describing links to files, bundles, other collections, and metadata fragments that are part of the collection.\n","items":{"$ref":"#/definitions/CollectionItem"},"type":"array"},"description":{"description":"A long description of the collection, formatted in Markdown.","type":"string"},"details":{"description":"Supplementary JSON metadata for the collection.","type":"object"},"name":{"description":"A short name identifying the collection.","type":"string"}},"required":["name","description","details","contents"],"type":"object"},"CollectionItem":{"properties":{"path":{"description":"JSON Pointer indexing into the JSON conents of the file containing a metadata fragment. Required for links of type other than file, bundle, or collection. Ignored otherwise.\n","type":"string"},"type":{"description":"Type of link (file, bundle, collection, or a custom type for a metadata fragment).","type":"string"},"uuid":{"description":"Unique ID of the file, bundle, collection, or file containing a metadata fragment.","pattern":"[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}","type":"string"},"version":{"description":"DSS_VERSION format timestamp of the file, bundle, collection, or file containing a metadata fragment.","format":"DSS_VERSION","type":"string"}},"required":["type","uuid","version"],"type":"object"},"Error":{"properties":{"code":{"description":"Machine-readable error code.  The types of return values should not be changed lightly.  Individual endpoints should list an enumeration of possible return codes.  All endpoints should expect the possibility of the return code `unhandled_exception` and `illegal_arguments`.\n","type":"string"},"stacktrace":{"description":"Exception stacktrace, if any.","type":"string"},"status":{"description":"HTTP error code.","format":"int32","type":"integer"},"title":{"description":"Human-readable error code.","type":"string"}},"required":["title"],"type":"object"},"File":{"properties":{"name":{"description":"Filename (unique within a bundle)","type":"string"},"uuid":{"description":"File unique ID","pattern":"[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}","type":"string"},"versions":{"description":"List of versions","items":{"type":"string"},"type":"array"}},"required":["uuid","name","versions"],"type":"object"},"FilesGetResponse":{"properties":{"files":{"type":"string"}},"type":"object"},"SearchResult":{"properties":{"es_query":{"description":"Elasticsearch query used to produce the results.","type":"object"},"results":{"description":"Results matching the `es_query`.","items":{"type":"object"},"type":"array"},"total_hits":{"description":"The total number of matching results found.","type":"integer"}},"type":"object"},"Subscription":{"properties":{"attachments":{"additionalProperties":{"properties":{"expression":{"description":"The JMESPath expression to evaluate against the bundle metadata JSON document. That document is of the same structure as those returned by `POST /search` with `output_format: raw`.\n","type":"string"},"type":{"description":"The type of the attachment. Currently only the `jmespath` type is supported.","enum":["jmespath"]}},"required":["type","expression"],"type":"object"},"description":"The set of bundle metadata items to be included in the payload of a notification request to a subscription endpoint. Each property in this object represents an attachment to the notification payload. Each attachment will be a child property of the `attachments` property of the payload. The name of such a child property can be chosen freely provided it does not start with an underscore.\nFor example, if the subscription is\n```\n{\n  \"attachments\": {\n    \"taxon\": {\n      \"type\": \"jmespath\",\n      \"expression\": \"files.biomaterial_json.biomaterials[].content.biomaterial_core.ncbi_taxon_id[]\"\n    }\n  }\n}\n```\nthe corresponding notification payload will contain the following entry\n```\n\"attachments\": {\n  \"taxon\": [9606, 9606]\n}\n```\nIf a general error occurs during the processing of attachments, the notification will be sent with `attachments` containing only the reserved `_errors` attachment containing a string describing the error. If an error occurs during the processing of a specific attachment, the notification will be sent with all successfully processed attachments and additionally the `_errors` attachment containing an object with one property for each failed attachment. For example,\n```\n\"attachments\": {\n  \"taxon\": [9606, 9606]\n  \"_errors\" {\n    \"biomaterial\": \"Some error occurred\"\n  }\n}\n```\nThe value of the `attachments` property must be less than or equal to 128 KiB in size when serialized to JSON and encoded as UTF-8. If it is not, the notification will be sent with\n```\n\"attachments\": {\n  \"_errors\": \"Attachments too large (131073 bytes)\"\n}\n```\n","type":"object"},"callback_url":{"description":"The subscriber\\'s URL. An HTTP request is made to the specified URL for every attempt to deliver a notification to the subscriber. If the HTTP response code is 2XX, the delivery attempt is considered successful and no more attemtpts will be made. Otherwise, more attempts will be made with an exponentially increasing delay between attempts, until an attempt is successful or the a maximum number of attempts is reached.\n","pattern":"https?://","type":"string"},"encoding":{"default":"application/json","description":"The MIME type describing the encoding of the request body * `application/json` - the HTTP request body is the notification payload as JSON * `multipart/form-data` - the HTTP request body is a list of form fields, each consisting of a name\n  and a corresponding value. See https://tools.ietf.org/html/rfc7578 for details on this encoding.\n  The actual notification payload will be placed as JSON into a field of the name specified via\n  `payload_form_field`.\n","enum":["application/json","multipart/form-data"]},"es_query":{"description":"An Elasticsearch query for restricting the set of bundles for which the subscriber is notified. The subscriber will only be notified for newly indexed bundles that match the given query.\n","type":"object"},"form_fields":{"additionalProperties":{"type":"string"},"default":{},"description":"A collection of static form fields to be supplied in the request body, alongside the actual notification payload. The value of each field must be a string. For example, if the subscriptions has this property set to `{\"foo\" : \"bar\"}`, the corresponding notification HTTP request body will be\n```\n--2769baffc4f24cbc83ced26aa0c2f712 Content-Disposition: form-data; name=\"foo\"\nbar Content-Disposition: form-data; name=\"payload\"\n{\"transaction_id\": \"301c9079-3b20-4311-a131-bcda9b7f08ba\", \"subscription_id\": ... --2769baffc4f24cbc83ced26aa0c2f712--\n```\nSince the type of this property is `object`, multi-valued fields are not supported. This property is ignored unless `encoding` is `multipart/form-data`.\n","type":"object"},"jmespath_query":{"description":"An JMESPath query for restricting the set of bundles for which the subscriber is notified. The subscriber will only be notified for new bundles that match the given query.\n","type":"string"},"method":{"default":"POST","description":"The HTTP request method to use when delivering a notification to the subscriber.","enum":["POST","PUT"]},"owner":{"description":"The email of the user who created this subscription.","format":"email","type":"string"},"payload_form_field":{"default":"payload","description":"The name of the form field that will hold the notification payload when the request is made. If the default name of the payload field collides with that of a field in `form_fields`, this porperty can be used to rename the payload and avoid the collision. This property is ignored unless `encoding` is `multipart/form-data`.\n","type":"string"},"replica":{"description":"The DSS replica to subscribe. When a new bundle is indexed in a particular replica, only subscriptions for that same replica are notified.\n","enum":["aws","gcp"],"type":"string"},"uuid":{"description":"Uniquely identifies this subscription.","pattern":"[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}","type":"string"}},"required":["uuid","replica","owner","callback_url"],"type":"object"},"bundle_version":{"properties":{"creator_uid":{"description":"User ID who created this bundle manifest.","format":"int","type":"integer"},"files":{"items":{"$ref":"#/definitions/file_version"},"type":"array"},"uuid":{"description":"Bundle unique ID","pattern":"[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}","type":"string"},"version":{"description":"Timestamp of bundle creation in DSS_VERSION format.","format":"DSS_VERSION","type":"string"}},"type":"object"},"file_version":{"description":"Object describing a single file in the files list of a bundle.","properties":{"content-type":{"description":"Content-type of the file.","type":"string"},"crc32c":{"description":"CRC-32C (in hex format) of the file contents in hex.","pattern":"^[a-z0-9]{8}$","type":"string"},"indexed":{"description":"True if this file is to be indexed.","type":"boolean"},"name":{"description":"Filename (unique within a bundle)","type":"string"},"s3_etag":{"description":"S3 ETag (in hex format) of the file contents.","pattern":"^[a-z0-9]{32}(-([2-9]|[1-8][0-9]|9[0-9]|[1-8][0-9]{2}|9[0-8][0-9]|99[0-9]|[1-8][0-9]{3}|9[0-8][0-9]{2}|99[0-8][0-9]|999[0-9]|10000))?$","type":"string"},"sha1":{"description":"SHA-1 (in hex format) of the file contents in hex.","pattern":"^[a-z0-9]{40}$","type":"string"},"sha256":{"description":"SHA-256 (in hex format) of the file contents in hex.","pattern":"^[a-z0-9]{64}$","type":"string"},"size":{"description":"File size (bytes).","format":"int64","type":"integer"},"url":{"description":"Direct access or presigned URL, if requested.","type":"string"},"uuid":{"description":"A RFC4122-compliant ID for the file.","pattern":"[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}","type":"string"},"version":{"description":"Timestamp of bundle creation in DSS_VERSION format.","format":"DSS_VERSION","type":"string"}},"required":["name","content-type","indexed","uuid","version","size","crc32c","s3_etag","sha1","sha256"],"type":"object"}},"host":"dss.dev.data.humancellatlas.org","info":{"description":"Human Cell Atlas Data Coordination Platform Data Storage System API\n# HTTP semantics\nThe DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:\n\n**301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.\n\n**Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.\n\n**General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.\n\nThe following Python code demonstrates an example configuration of the popular Requests library per the above guidance:\n```\nimport requests, requests.packages.urllib3.util.retry\nclass RetryPolicy(requests.packages.urllib3.util.retry.Retry):\n    def __init__(self, retry_after_status_codes={301}, **kwargs):\n        super(RetryPolicy, self).__init__(**kwargs)\n        self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)\n\nretry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504}))\ns = requests.Session()\na = requests.adapters.HTTPAdapter(max_retries=retry_policy)\ns.mount('https://', a)\nprint(s.get(\"https://dss.data.humancellatlas.org\").content)\n```\n# Special String Formats\n\n**DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z`\n","title":"HCA DCP DSS API","version":"0.0.2"},"paths":{"/bundles/checkout/{checkout_job_id}":{"get":{"description":"Use this route with the `checkout_job_id` identifier returned by `POST /bundles/{uuid}/checkout`.\n","operationId":"dss.api.bundles.checkout.get","parameters":[{"description":"Replica to fetch from.","enum":["aws","gcp"],"in":"query","name":"replica","required":true,"type":"string"},{"description":"A RFC4122-compliant ID for the checkout job request.","in":"path","name":"checkout_job_id","pattern":"[A-Za-z0-9]{8}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{12}","required":true,"type":"string"}],"responses":{"200":{"description":"Returned when a checkout request for the checkout job id exists.","schema":{"properties":{"cause":{"description":"Human readable description of the error, returned for FAILED status only.","type":"string"},"status":{"description":"Status of the checkout request.","enum":["RUNNING","SUCCEEDED","FAILED","UNKNOWN_JOB_ID"],"type":"string"}},"required":["status"],"type":"object"}},"404":{"description":"Cannot find checkout.","schema":{"allOf":[{"$ref":"#/definitions/Error"},{"properties":{"code":{"description":"Machine-readable error code.  The types of return values should not be changed lightly.\n\nThe code `not_found` is returned when there is no record of the checkout being referenced.\n","enum":["not_found"],"type":"string"},"message":{"description":"Detailed error message.","type":"string"}},"required":["code"],"type":"object"}]}},"default":{"description":"Unexpected error","schema":{"allOf":[{"$ref":"#/definitions/Error"},{"properties":{"code":{"description":"Machine-readable error code.  The types of return values should not be changed lightly.","enum":["unhandled_exception","illegal_arguments"],"type":"string"},"message":{"description":"Detailed error message.","type":"string"}},"required":["code"],"type":"object"}]}}},"summary":"Check the status of a checkout request."}},"/bundles/{uuid}":{"delete":{"description":"Delete the bundle with the given UUID. This deletion is applied across replicas.\n","parameters":[{"description":"A RFC4122-compliant ID for the bundle.","in":"path","name":"uuid","pattern":"[A-Za-z0-9]{8}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{12}","required":true,"type":"string"},{"description":"Replica to write to.","enum":["aws","gcp"],"in":"query","name":"replica","required":true,"type":"string"},{"description":"Timestamp of bundle creation in DSS_VERSION format.","in":"query","name":"version","required":false,"type":"string"},{"in":"body","name":"json_request_body","required":true,"schema":{"properties":{"reason":{"description":"User-friendly reason for the bundle or timestamp-specfic bundle deletion.","type":"string"}},"required":["reason"],"type":"object"}}],"responses":{"200":{"description":"OK","schema":{"type":"object"}},"401":{"description":"Unauthorized user it attempting this action.","schema":{"allOf":[{"$ref":"#/definitions/Error"},{"properties":{"code":{"description":"Machine-readable error code.  The types of return values should not be changed lightly.","enum":["Unauthorized"],"type":"string"}},"required":["code"],"type":"object"}]}},"403":{"description":"Unauthorized user it attempting this action.","schema":{"allOf":[{"$ref":"#/definitions/Error"},{"properties":{"code":{"description":"Machine-readable error code.  The types of return values should not be changed lightly.","enum":["Forbidden"],"type":"string"}},"required":["code"],"type":"object"}]}},"409":{"description":"Unexpected error","schema":{"allOf":[{"$ref":"#/definitions/Error"},{"properties":{"code":{"description":"Machine-readable error code.  The types of return values should not be changed lightly.","enum":["bundle_tombstone_already_exists"],"type":"string"}},"required":["code"],"type":"object"}]}},"default":{"description":"Unexpected error","schema":{"allOf":[{"$ref":"#/definitions/Error"},{"properties":{"code":{"description":"Machine-readable error code.  The types of return values should not be changed lightly.","enum":["unhandled_exception","illegal_arguments","read_only"],"type":"string"}},"required":["code"],"type":"object"}]}}},"security":[{"dcpAuth":[]}],"summary":"Delete a bundle or a specific bundle version"},"get":{"description":"Given a bundle UUID, return the latest version of that bundle.  If the version is provided, that version of the bundle is returned instead.\n","parameters":[{"description":"Bundle unique ID.","in":"path","name":"uuid","pattern":"[A-Za-z0-9]{8}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{12}","required":true,"type":"string"},{"description":"Timestamp of bundle creation in DSS_VERSION format.","in":"query","name":"version","required":false,"type":"string"},{"description":"Replica to fetch from.","enum":["aws","gcp"],"in":"query","name":"replica","required":true,"type":"string"},{"description":"Include direct-access URLs in the response.  This is mutually exclusive with the presignedurls parameter.\n","in":"query","name":"directurls","required":false,"type":"boolean"},{"description":"Include presigned URLs in the response.  This is mutually exclusive with the directurls parameter.\n","in":"query","name":"presignedurls","required":false,"type":"boolean"},{"description":"Token to manage retries.  End users constructing queries should not set this parameter.","in":"query","name":"token","required":false,"type":"string"}],"responses":{"200":{"description":"OK","schema":{"properties":{"bundle":{"$ref":"#/definitions/bundle_version"}},"type":"object"}},"301":{"description":"Handle asynchronously, downstream users are expected to retry later.","headers":{"Retry-After":{"description":"Delay in seconds, downstream users are expected to retry after the delay.","format":"int64","type":"integer"}}},"400":{"description":"Bad request","schema":{"allOf":[{"$ref":"#/definitions/Error"},{"properties":{"code":{"description":"Machine-readable error code.  The types of return values should not be changed lightly.\n\nThe code `illegal_arguments` is returned when required parameters are missing or parameters do not match the requirements in the specification.\n\nThe code `illegal_token` is returned when the token parameter cannot be understood.\n\nThe code `only_one_urltype` is returned when more than one url type (`directurls` and `presignedurls`) is requested.\n","enum":["illegal_arguments","illegal_token","only_one_urltype"],"type":"string"}},"required":["code"],"type":"object"}]}},"500":{"description":"Server error","schema":{"allOf":[{"$ref":"#/definitions/Error"},{"properties":{"code":{"description":"Machine-readable error code.  The types of return values should not be changed lightly.\n\nThe code `unhandled_exception` is returned when an unexpected exception is encountered.\n\nThe code `checkout_error` is returned when the checkout fails.\n","enum":["unhandled_exception","checkout_error"],"type":"string"}},"required":["code"],"type":"object"}]}},"503":{"description":"Service unavailable","schema":{"allOf":[{"$ref":"#/definitions/Error"},{"properties":{"code":{"description":"Machine-readable error code.  The types of return values should not be changed lightly.\n\nThe code `service_unavailable` is returned when service is unavailable because of unusually high load/latency\n","enum":["service_unavailable"],"type":"string"}},"required":["code"],"type":"object"}]}}},"summary":"Retrieve a bundle given a UUID and optionally a version."},"put":{"description":"Create a new version of a bundle with a given UUID.  The list of file UUID+versions to be included must be provided.\n","parameters":[{"description":"A RFC4122-compliant ID for the bundle.","in":"path","name":"uuid","pattern":"[A-Za-z0-9]{8}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{12}","required":true,"type":"string"},{"description":"Timestamp of bundle creation in DSS_VERSION format.","format":"DSS_VERSION","in":"query","name":"version","required":true,"type":"string"},{"description":"Replica to write to.","enum":["aws","gcp"],"in":"query","name":"replica","required":true,"type":"string"},{"in":"body","name":"json_request_body","required":true,"schema":{"properties":{"creator_uid":{"description":"User ID who is creating this bundle.","format":"int64","type":"integer"},"files":{"items":{"properties":{"indexed":{"description":"True iff this file should be indexed.","type":"boolean"},"name":{"description":"Name of the file.","pattern":"^[^/\\\\]+$","type":"string"},"uuid":{"description":"A RFC4122-compliant ID for the file.","pattern":"[A-Za-z0-9]{8}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{12}","type":"string"},"version":{"description":"Timestamp of file creation in DSS_VERSION format.","format":"DSS_VERSION","type":"string"}},"required":["uuid","version","name","indexed"],"type":"object"},"type":"array"}},"required":["files","creator_uid"],"type":"object"}}],"responses":{"200":{"description":"OK","schema":{"properties":{"manifest":{"description":"The manifest stored in the DSS. It lists the files in the bundle, and metadata describing those files.","type":"object"},"version":{"description":"Timestamp of bundle creation in DSS_VERSION format.","format":"DSS_VERSION","type":"string"}},"required":["version","manifest"],"type":"object"}},"201":{"description":"OK","schema":{"properties":{"manifest":{"description":"The manifest stored in the DSS. It lists the files in the bundle, and metadata describing those files.","type":"object"},"version":{"description":"Timestamp of bundle creation in DSS_VERSION format.","format":"DSS_VERSION","type":"string"}},"required":["version","manifest"],"type":"object"}},"400":{"description":"Returned when the server could not process the request.  Examine the code for more details.","schema":{"allOf":[{"$ref":"#/definitions/Error"},{"properties":{"code":{"description":"Machine-readable error code.  The types of return values should not be changed lightly.\nThe code `duplicate_filename` is returned when the bundle contains two files of the same name.\nThe code `file_missing` is returned when the server cannot find one of the files requested to be included in the bundle.\nThe code `illegal_version` is returned when version is not a DSS_VERSION format-compliant timestamp.\n","enum":["duplicate_filename","file_missing","illegal_version"],"type":"string"}},"required":["code"],"type":"object"}]}},"409":{"description":"Returned when a bundle with the same UUID and version already exists","schema":{"allOf":[{"$ref":"#/definitions/Error"},{"properties":{"code":{"description":"Machine-readable error code.  The types of return values should not be changed lightly.","enum":["bundle_already_exists"],"type":"string"}},"required":["code"],"type":"object"}]}},"default":{"description":"Unexpected error","schema":{"allOf":[{"$ref":"#/definitions/Error"},{"properties":{"code":{"description":"Machine-readable error code.  The types of return values should not be changed lightly.","enum":["unhandled_exception","Forbidden","Unauthorized","illegal_arguments","read_only"],"type":"string"}},"required":["code"],"type":"object"}]}}},"security":[{"dcpAuth":[]}],"summary":"Create a bundle"}},"/bundles/{uuid}/checkout":{"post":{"description":"Initiate asynchronous checkout of a bundle. The response JSON contains a field, `checkout_job_id`, that can be used to query the status of the checkout via the `GET /bundles/checkout/{checkout_job_id}` API method. FIXME: document the error code returned when the bundle or specified version does not exist. TODO: After some time period, the data will be removed. TBD: This could be based on initial checkout time or last access time.\n","operationId":"dss.api.bundles.checkout.post","parameters":[{"description":"A RFC4122-compliant ID for the bundle.","in":"path","name":"uuid","pattern":"[A-Za-z0-9]{8}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{12}","required":true,"type":"string"},{"description":"Timestamp of file creation in DSS_VERSION format.  If this is not provided, the latest version is returned.","in":"query","name":"version","required":false,"type":"string"},{"description":"Replica to fetch from.","enum":["aws","gcp"],"in":"query","name":"replica","required":true,"type":"string"},{"in":"body","name":"json_request_body","required":false,"schema":{"properties":{"destination":{"description":"User-owned destination storage bucket.","type":"string"},"email":{"description":"An email address to send status updates to.","format":"email","type":"string"}},"type":"object"}}],"responses":{"200":{"description":"Returned when the bundle UUID with optionally specified version exists and checkout has been initiated.","schema":{"properties":{"checkout_job_id":{"description":"A RFC4122-compliant ID for the checkout job request.","pattern":"[A-Za-z0-9]{8}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{12}","type":"string"}},"required":["checkout_job_id"],"type":"object"}},"default":{"description":"Unexpected error","schema":{"allOf":[{"$ref":"#/definitions/Error"},{"properties":{"code":{"description":"Machine-readable error code.  The types of return values should not be changed lightly.","enum":["unhandled_exception","illegal_arguments","not_found"],"type":"string"}},"required":["code"],"type":"object"}]}}},"summary":"Check out a bundle to DSS-managed or user-managed cloud object storage destination"}},"/collections":{"put":{"description":"Create a new collection.\n\nCollections are sets of links to files, bundles, other collections, or fragments of JSON metadata files. Each entry in the input set of links is checked for referential integrity (the link target must exist in the replica referenced). Up to 1000 items can be referenced in a new collection, or added or removed using `PATCH /collections`. New collections are private to the authenticated user.\n\nCollection items are de-duplicated (if an identical item is given multiple times, it will only be added once).\n\nCollections are replicated across storage replicas similarly to files and bundles.\n","parameters":[{"description":"Replica to write to.","enum":["aws","gcp"],"in":"query","name":"replica","required":true,"type":"string"},{"description":"A RFC4122-compliant ID for the collection.","in":"query","name":"uuid","pattern":"[A-Za-z0-9]{8}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{12}","required":true,"type":"string"},{"description":"Timestamp of collection creation in DSS_VERSION format format. If this is not provided, the version is automatically generated.\n","format":"DSS_VERSION","in":"query","name":"version","required":true,"type":"string"},{"in":"body","name":"json_request_body","required":true,"schema":{"$ref":"#/definitions/Collection"}}],"responses":{"201":{"description":"OK","schema":{"properties":{"uuid":{"description":"A RFC4122-compliant ID for the collection.","pattern":"[A-Za-z0-9]{8}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{12}","type":"string"}},"required":["uuid"],"type":"object"}},"default":{"description":"Unexpected error","schema":{"allOf":[{"$ref":"#/definitions/Error"},{"properties":{"code":{"description":"Machine-readable error code.  The types of return values should not be changed lightly.\n\nThe code `invalid_link` indicates that an item listed in the collection contents field of the input could not be resolved (either because the file, bundle, or collection does not exist on the replica specified, or because the JSON Pointer reference could not be resolved within the specified file).\n","enum":["unhandled_exception","Forbidden","Unauthorized","OAuthResponseProblem","not_found","invalid_link","read_only"],"type":"string"}},"required":["code"],"type":"object"}]}}},"security":[{"dcpAuth":[]}],"summary":"Create a collection."}},"/collections/{uuid}":{"delete":{"description":"Delete a collection.\n","parameters":[{"description":"A RFC4122-compliant ID for the collection.","in":"path","name":"uuid","pattern":"[A-Za-z0-9]{8}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{12}","required":true,"type":"string"},{"description":"Replica to delete from.","enum":["aws","gcp"],"in":"query","name":"replica","required":true,"type":"string"}],"responses":{"200":{"description":"OK"},"default":{"description":"Unexpected error","schema":{"allOf":[{"$ref":"#/definitions/Error"},{"properties":{"code":{"description":"Machine-readable error code.  The types of return values should not be changed lightly.","enum":["unhandled_exception","Forbidden","Unauthorized","OAuthResponseProblem","not_found","read_only"],"type":"string"}},"required":["code"],"type":"object"}]}}},"security":[{"dcpAuth":[]}],"summary":"Delete a collection."},"get":{"description":"Given a collection UUID, return the associated collection object.\n","parameters":[{"description":"A RFC4122-compliant ID for the collection.","in":"path","name":"uuid","pattern":"[A-Za-z0-9]{8}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{12}","required":true,"type":"string"},{"description":"Replica to fetch from.","enum":["aws","gcp"],"in":"query","name":"replica","required":true,"type":"string"},{"description":"Timestamp of collection creation in DSS_VERSION format.  If this is not provided, the latest version is returned.\n","in":"query","name":"version","required":false,"type":"string"}],"responses":{"200":{"description":"OK","schema":{"properties":{"collection":{"$ref":"#/definitions/Collection"}},"type":"object"}},"default":{"description":"Unexpected error","schema":{"allOf":[{"$ref":"#/definitions/Error"},{"properties":{"code":{"description":"Machine-readable error code.  The types of return values should not be changed lightly.","enum":["unhandled_exception","Forbidden","Unauthorized","OAuthResponseProblem","not_found"],"type":"string"}},"required":["code"],"type":"object"}]}}},"security":[{"dcpAuth":[]}],"summary":"Retrieve a collection given a UUID."},"patch":{"description":"Add or remove items from a collection. A specific version of the collection to update must be provided, and a new version will be written.\n","parameters":[{"description":"A RFC4122-compliant ID of the collection to update.","in":"path","name":"uuid","pattern":"[A-Za-z0-9]{8}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{12}","required":true,"type":"string"},{"description":"Replica to update the collection on. Updates are propagated to other replicas.","enum":["aws","gcp"],"in":"query","name":"replica","required":true,"type":"string"},{"description":"Timestamp of the collection to update in DSS_VERSION format format (required).\n","format":"DSS_VERSION","in":"query","name":"version","required":true,"type":"string"},{"in":"body","name":"json_request_body","required":true,"schema":{"properties":{"add_contents":{"description":"List of new items to add to the collection. Items are de-duplicated (if an identical item is already present in the collection or given multiple times, it will only be added once).\n","items":{"$ref":"#/definitions/CollectionItem"},"maxItems":1000,"type":"array"},"description":{"description":"New description for the collection.","type":"string"},"details":{"description":"New details for the collection.","type":"object"},"name":{"description":"New name for the collection.","type":"string"},"remove_contents":{"description":"List of items to remove from the collection. Items must match exactly to be removed. Items not found in the collection are ignored.\n","items":{"$ref":"#/definitions/CollectionItem"},"maxItems":1000,"type":"array"}},"type":"object"}}],"responses":{"200":{"description":"OK","schema":{"properties":{"uuid":{"description":"A RFC4122-compliant ID of this collection.","type":"string"},"version":{"description":"New version of the updated collection.","format":"DSS_VERSION","type":"string"}},"required":["uuid","version"],"type":"object"}},"400":{"description":"Returned when the server could not process the request due to incorrect inputs.  Examine the code for more details.\n","schema":{"allOf":[{"$ref":"#/definitions/Error"},{"properties":{"code":{"description":"The code `illegal_version` is returned when version is not a DSS_VERSION format-compliant timestamp.\n","enum":["illegal_version"],"type":"string"}},"required":["code"],"type":"object"}]}},"403":{"description":"Returned when credentials presented do not grant access to this collection.\n","schema":{"allOf":[{"$ref":"#/definitions/Error"},{"properties":{"code":{"description":"Machine-readable error code.  The types of return values should not be changed lightly.\nThe code `Forbidden` indicates that the user does not have access to this collection.\nThe code `OAuthResponseProblem` indicates that the OAuth credentials presented were not understood.\n","enum":["Forbidden","OAuthResponseProblem"],"type":"string"}},"required":["code"],"type":"object"}]}},"404":{"description":"Returned when the server could not find the collection to patch.\n","schema":{"allOf":[{"$ref":"#/definitions/Error"},{"properties":{"code":{"description":"Machine-readable error code.  The types of return values should not be changed lightly.\n","enum":["not_found"],"type":"string"}},"required":["code"],"type":"object"}]}},"422":{"description":"Returned when the server could not find some of the files necessary to complete the operation or if the JSON Pointer reference could not be resolved within the specified file.\n","schema":{"allOf":[{"$ref":"#/definitions/Error"},{"properties":{"code":{"description":"Machine-readable error code.  The types of return values should not be changed lightly.\n","enum":["invalid_link"],"type":"string"}},"required":["code"],"type":"object"}]}},"default":{"description":"Unexpected error","schema":{"allOf":[{"$ref":"#/definitions/Error"},{"properties":{"code":{"description":"Machine-readable error code.  The types of return values should not be changed lightly.\n","enum":["unhandled_exception","illegal_arguments"],"type":"string"}},"required":["code"],"type":"object"}]}}},"security":[{"dcpAuth":[]}],"summary":"Update a collection."}},"/files/{uuid}":{"get":{"description":"Given a file UUID, return the latest version of that file.  If the version is provided, that version of the file is returned instead.\nHeaders will contain the data store metadata for the file.\nThis endpoint returns a HTTP redirect to another HTTP endpoint with the file contents.\n","parameters":[{"description":"A RFC4122-compliant ID for the file.","in":"path","name":"uuid","pattern":"[A-Za-z0-9]{8}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{12}","required":true,"type":"string"},{"description":"Replica to fetch from.","enum":["aws","gcp"],"in":"query","name":"replica","required":true,"type":"string"},{"description":"Timestamp of file creation in DSS_VERSION format.  If this is not provided, the latest version is returned.","in":"query","name":"version","required":false,"type":"string"},{"description":"Token to manage retries.  End users constructing queries should not set this parameter.","in":"query","name":"token","required":false,"type":"string"}],"responses":{"301":{"description":"Handle asynchronously, downstream users are expected to retry later.","headers":{"Retry-After":{"description":"Delay in seconds, downstream users are expected to retry after the delay.","format":"int64","type":"integer"}}},"302":{"description":"Redirects to a signed URL with the data.","headers":{"X-DSS-CONTENT-TYPE":{"description":"Content-type of the file.","type":"string"},"X-DSS-CRC32C":{"description":"CRC-32C (in hex format) of the file contents in hex.","pattern":"^[a-z0-9]{8}$","type":"string"},"X-DSS-CREATOR-UID":{"description":"User ID who created this file.","format":"int64","type":"integer"},"X-DSS-S3-ETAG":{"description":"S3 ETag (in hex format) of the file contents.","pattern":"^[a-z0-9]{32}(-([2-9]|[1-8][0-9]|9[0-9]|[1-8][0-9]{2}|9[0-8][0-9]|99[0-9]|[1-8][0-9]{3}|9[0-8][0-9]{2}|99[0-8][0-9]|999[0-9]|10000))?$","type":"string"},"X-DSS-SHA1":{"description":"SHA-1 (in hex format) of the file contents in hex.","pattern":"^[a-z0-9]{40}$","type":"string"},"X-DSS-SHA256":{"description":"SHA-256 (in hex format) of the file contents in hex.","pattern":"^[a-z0-9]{64}$","type":"string"},"X-DSS-SIZE":{"description":"File size (bytes).","format":"int64","type":"integer"},"X-DSS-VERSION":{"description":"Timestamp of file creation in DSS_VERSION format.","format":"DSS_VERSION","type":"string"}}},"400":{"description":"Bad request","schema":{"allOf":[{"$ref":"#/definitions/Error"},{"properties":{"code":{"description":"Machine-readable error code.  The types of return values should not be changed lightly.\nThe code `illegal_token` is returned when the token parameter cannot be understood.\n","enum":["illegal_token"],"type":"string"}},"required":["code"],"type":"object"}]}},"default":{"description":"Unexpected error","schema":{"allOf":[{"$ref":"#/definitions/Error"},{"properties":{"code":{"description":"Machine-readable error code.  The types of return values should not be changed lightly.","enum":["unhandled_exception","illegal_arguments","not_found"],"type":"string"}},"required":["code"],"type":"object"}]}}},"summary":"Retrieve a file given a UUID and optionally a version."},"head":{"description":"Given a file UUID, return the metadata for the latest version of that file.  If the version is provided, that version's metadata is returned instead.  The metadata is returned in the headers.\n","parameters":[{"description":"A RFC4122-compliant ID for the file.","in":"path","name":"uuid","required":true,"type":"string"},{"description":"Replica to fetch from.","enum":["aws","gcp"],"in":"query","name":"replica","required":true,"type":"string"},{"description":"Timestamp of file creation in DSS_VERSION format.  If this is not provided, the latest version is returned.","in":"query","name":"version","required":false,"type":"string"}],"responses":{"200":{"description":"Returns metadata","headers":{"X-DSS-CONTENT-TYPE":{"description":"Content-type of the file.","type":"string"},"X-DSS-CRC32C":{"description":"CRC-32C (in hex format) of the file contents in hex.","pattern":"^[a-z0-9]{8}$","type":"string"},"X-DSS-CREATOR-UID":{"description":"User ID who created this file.","format":"int64","type":"integer"},"X-DSS-S3-ETAG":{"description":"S3 ETag (in hex format) of the file contents.","pattern":"^[a-z0-9]{32}(-([2-9]|[1-8][0-9]|9[0-9]|[1-8][0-9]{2}|9[0-8][0-9]|99[0-9]|[1-8][0-9]{3}|9[0-8][0-9]{2}|99[0-8][0-9]|999[0-9]|10000))?$","type":"string"},"X-DSS-SHA1":{"description":"SHA-1 (in hex format) of the file contents in hex.","pattern":"^[a-z0-9]{40}$","type":"string"},"X-DSS-SHA256":{"description":"SHA-256 (in hex format) of the file contents in hex.","pattern":"^[a-z0-9]{64}$","type":"string"},"X-DSS-SIZE":{"description":"File size (bytes).","format":"int64","type":"integer"},"X-DSS-VERSION":{"description":"Timestamp of file creation in DSS_VERSION format.","type":"string"}}}},"summary":"Retrieve a file's metadata given an UUID and optionally a version."},"put":{"description":"Create a new version of a file with a given UUID. The contents of the file are provided by the client by reference using a cloud object storage URL. The file on the cloud object storage service must have metadata set listing the file checksums and content-type.\nThe metadata fields required are:\n- hca-dss-sha256: SHA-256 checksum of the file - hca-dss-sha1: SHA-1 checksum of the file - hca-dss-s3_etag: S3 ETAG checksum of the file.  See https://stackoverflow.com/questions/12186993/what-is-the-algorithm-to-compute-the-amazon-s3-etag-for-a-file-larger-than-5gb for the general algorithm for how checksum is calculated.  For files smaller than 64MB, this is the MD5 checksum of the file.  For files larger than 64MB but smaller than 640,000MB, we use 64MB chunks.  For files larger than 640,000MB, we use a chunk size equal to the total file size divided by 10000, rounded up to the nearest MB. MB, in this section, refers to 1,048,576 bytes.  Note that 640,000MB is not the same as 640GB! - hca-dss-crc32c: CRC-32C checksum of the file\n","parameters":[{"description":"A RFC4122-compliant ID for the file.","in":"path","name":"uuid","pattern":"[A-Za-z0-9]{8}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{12}","required":true,"type":"string"},{"description":"Timestamp of file creation in DSS_VERSION format.  If this is not provided, the latest version is returned.","format":"DSS_VERSION","in":"query","name":"version","required":true,"type":"string"},{"in":"body","name":"json_request_body","required":true,"schema":{"properties":{"creator_uid":{"description":"User ID who is creating this file.","format":"int64","type":"integer"},"source_url":{"description":"Cloud URL for source data.","pattern":"^(gs|s3|wasb)://","type":"string"}},"required":["source_url","creator_uid"],"type":"object"}}],"responses":{"200":{"description":"Returned when the file is already present and is identical to the file being uploaded.","schema":{"properties":{"version":{"description":"Timestamp of file creation in DSS_VERSION format.","format":"DSS_VERSION","type":"string"}},"required":["version"],"type":"object"}},"201":{"description":"Returned when the file is successfully copied.","schema":{"properties":{"version":{"description":"Timestamp of file creation in DSS_VERSION format.","format":"DSS_VERSION","type":"string"}},"required":["version"],"type":"object"}},"202":{"description":"Returned when the file has been queued up for copying.","schema":{"properties":{"task_id":{"description":"ID for the task responsible for managing the copy.","pattern":"[A-Za-z0-9]{8}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{12}","type":"string"},"version":{"description":"Timestamp of file creation in DSS_VERSION format.","format":"DSS_VERSION","type":"string"}},"required":["version"],"type":"object"}},"400":{"description":"Returned when the server could not process the request.  Examine the code for more details.","schema":{"allOf":[{"$ref":"#/definitions/Error"},{"properties":{"code":{"description":"Machine-readable error code.  The types of return values should not be changed lightly.\nThe code `unknown_source_schema` is returned when the source_url of the file has an unsupported schema.\nThe code `illegal_version` is returned when version is not a DSS_VERSION format-compliant timestamp.\n","enum":["unknown_source_schema","illegal_version"],"type":"string"}},"required":["code"],"type":"object"}]}},"409":{"description":"Returned when a file with the same UUID and version already exists","schema":{"allOf":[{"$ref":"#/definitions/Error"},{"properties":{"code":{"description":"Machine-readable error code.  The types of return values should not be changed lightly.","enum":["file_already_exists"],"type":"string"}},"required":["code"],"type":"object"}]}},"422":{"description":"Returned when a request cannot be processed due to invalid values in a supplied entity.","schema":{"allOf":[{"$ref":"#/definitions/Error"},{"properties":{"code":{"description":"Machine-readable error code.  The types of return values should not be changed lightly.\nThe code `missing_checksum` is returned when the file uploaded is missing a required checksum.","enum":["missing_checksum"],"type":"string"}},"required":["code"],"type":"object"}]}},"default":{"description":"Unexpected error","schema":{"allOf":[{"$ref":"#/definitions/Error"},{"properties":{"code":{"description":"Machine-readable error code.  The types of return values should not be changed lightly.","enum":["unhandled_exception","Forbidden","Unauthorized","illegal_arguments","read_only"],"type":"string"}},"required":["code"],"type":"object"}]}}},"security":[{"dcpAuth":[]}],"summary":"Create a new version of a file"}},"/search":{"post":{"description":"Accepts Elasticsearch JSON query and returns matching bundle identifiers\n# Pagination\nThe DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved.\n# Index design\nThe metadata seach index is implemented as a [document-oriented database](https://en.wikipedia.org/wiki/Document-oriented_database) using [Elasticsearch](https://www.elastic.co/). The index stores all information relevant to a bundle within each bundle document, largely eliminating the need for [object-relational mapping](https://en.wikipedia.org/wiki/Object-relational_mapping). This design is optimized for queries that filter the data.\n\nTo illustrate this concept, say our index stored information on three entities, `foo`, `bar`, and `baz`. A foo can have many bars and bars can have many bazes. If we were to index bazes in a document-oriented design, the information on the foo a bar comes from and the bazes it contains are combined into a single document. A example sketch of this is shown below in [JSON-schema](https://en.wikipedia.org/wiki/JSON#JSON_Schema).\n```\n{\n  \"definitions\": {\n    \"bar\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"uuid\": {\n          \"type\": \"string\",\n          \"format\": \"uuid\"\n        },\n        \"foo\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"uuid\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            ...\n          }\n        },\n        \"bazes\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\"\n          }\n        },\n        ...\n      }\n    }\n  }\n}\n```\nThis closely resembles the structure of DSS bundle documents: projects have many bundles and bundles have many files. Each bundle document is a concatenation of the metadata on the project it belongs to and the files it contains.\n# Limitations to index design\nThere are limitations to the design of DSS's metadata search index. A few important ones are listed below.\n* [Joins](https://en.wikipedia.org/wiki/Join_(SQL)) between bundle metadata must be conducted client-side\n* Querying is schema-specific; fields or values changed between schema version will break queries that use those fields and values\n* A new search index must be built for each schema version\n* A lot of metadata is duplicated between documents\n","parameters":[{"in":"body","name":"json_request_body","required":true,"schema":{"properties":{"es_query":{"description":"Elasticsearch query","type":"object"}},"required":["es_query"],"type":"object"}},{"default":"summary","description":"Specifies the output format. The default format, `summary`, is a list of UUIDs for bundles that match the query. Set this parameter to `raw` to get the verbatim JSON metadata for bundles that match the query. When using `output_format raw` the `per_page` size is limit to no more than 10 to avoid excessively large response sizes.\n","enum":["summary","raw"],"in":"query","name":"output_format","required":false,"type":"string"},{"description":"Replica to search.","enum":["aws","gcp"],"in":"query","name":"replica","required":true,"type":"string"},{"default":100,"description":"Max number of results to return per page. When using `output_format raw` the `per_page` size is limit to no more than 10 to avoid excessively large response sizes.","format":"int32","in":"query","maximum":500,"minimum":10,"name":"per_page","required":false,"type":"integer"},{"description":"**Search-After-Context**. An internal state pointer parameter for use with pagination. This parameter is referenced by the `Link` header as described in the \"Pagination\" section. The API client should not need to set this parameter directly; it should instead directly fetch the URL given in the `Link` header.\n","in":"query","name":"search_after","required":false,"type":"string"}],"responses":{"200":{"description":"All results retrieved.","schema":{"$ref":"#/definitions/SearchResult"}},"206":{"description":"A single page of results was retrieved.","headers":{"Link":{"description":"URL to retrieve the next page of results.","type":"string"}},"schema":{"$ref":"#/definitions/SearchResult"}},"default":{"description":"Unexpected error","schema":{"$ref":"#/definitions/Error"}}},"summary":"Find bundles by searching their metadata with an Elasticsearch query\n"}},"/subscriptions":{"get":{"description":"Return a list of associated subscriptions.\n","operationId":"dss.api.subscriptions.find","parameters":[{"description":"Replica to fetch from.","enum":["aws","gcp"],"in":"query","name":"replica","required":true,"type":"string"},{"default":"elasticsearch","description":"type of subscriptions to fetch (elasticsearch or jmespath)","enum":["elasticsearch","jmespath"],"in":"query","name":"subscription_type","required":false,"type":"string"}],"responses":{"200":{"description":"OK","schema":{"properties":{"subscriptions":{"items":{"$ref":"#/definitions/Subscription"},"type":"array"}},"required":["subscriptions"],"type":"object"}},"default":{"description":"Unexpected error","schema":{"allOf":[{"$ref":"#/definitions/Error"},{"properties":{"code":{"description":"Machine-readable error code.  The types of return values should not be changed lightly.","enum":["unhandled_exception","Forbidden","Unauthorized","OAuthResponseProblem"],"type":"string"}},"required":["code"],"type":"object"}]}}},"security":[{"dcpAuth":[]}],"summary":"Retrieve a user\\'s event subscriptions."},"put":{"description":"Register an HTTP endpoint that is to be notified when a given event occurs.\n","parameters":[{"description":"Replica to write to.","enum":["aws","gcp"],"in":"query","name":"replica","required":true,"type":"string"},{"in":"body","name":"json_request_body","required":true,"schema":{"additionalProperties":false,"properties":{"attachments":{"additionalProperties":{"properties":{"expression":{"description":"The JMESPath expression to evaluate against the bundle metadata JSON document. That document is of the same structure as those returned by `POST /search` with `output_format: raw`.\n","type":"string"},"type":{"description":"The type of the attachment. Currently only the `jmespath` type is supported.","enum":["jmespath"]}},"required":["type","expression"],"type":"object"},"description":"The set of bundle metadata items to be included in the payload of a notification request to a subscription endpoint. Each property in this object represents an attachment to the notification payload. Each attachment will be a child property of the `attachments` property of the payload. The name of such a child property can be chosen freely provided it does not start with an underscore.\nFor example, if the subscription is\n```\n{\n  \"attachments\": {\n    \"taxon\": {\n      \"type\": \"jmespath\",\n      \"expression\": \"files.biomaterial_json.biomaterials[].content.biomaterial_core.ncbi_taxon_id[]\"\n    }\n  }\n}\n```\nthe corresponding notification payload will contain the following entry\n```\n\"attachments\": {\n  \"taxon\": [9606, 9606]\n}\n```\nIf a general error occurs during the processing of attachments, the notification will be sent with `attachments` containing only the reserved `_errors` attachment containing a string describing the error. If an error occurs during the processing of a specific attachment, the notification will be sent with all successfully processed attachments and additionally the `_errors` attachment containing an object with one property for each failed attachment. For example,\n```\n\"attachments\": {\n  \"taxon\": [9606, 9606]\n  \"_errors\" {\n    \"biomaterial\": \"Some error occurred\"\n  }\n}\n```\nThe value of the `attachments` property must be less than or equal to 128 KiB in size when serialized to JSON and encoded as UTF-8. If it is not, the notification will be sent with\n\"attachments\": {\n  \"_errors\": \"Attachments too large (131073 bytes)\"\n}\n","type":"object"},"callback_url":{"description":"The subscriber's URL. An HTTP request is made to the specified URL for every attempt to deliver a notification to the subscriber. If the HTTP response code is 2XX, the delivery attempt is considered successful. Otherwise, more attempts will be made with an exponentially increasing delay between attempts, until an attempt is successful or the a maximum number of attempts is reached.\nOccasionally duplicate notifications maybe be sent. It is up to the receiver of the notification to tolerate duplicate notifications.\n","pattern":"https?://","type":"string"},"encoding":{"default":"application/json","description":"The MIME type describing the encoding of the request body * `application/json` - the HTTP request body is the notification payload as JSON * `multipart/form-data` - the HTTP request body is a list of form fields, each consisting of a name\n  and a corresponding value. See https://tools.ietf.org/html/rfc7578 for details on this encoding.\n  The actual notification payload will be placed as JSON into a field of the name specified via\n  `payload_form_field`.\n","enum":["application/json","multipart/form-data"]},"es_query":{"description":"An Elasticsearch query for restricting the set of bundles for which the subscriber is notified. The subscriber will only be notified for newly indexed bundles that match the given query. If this parameter is present the subscription will be of type `elasticsearch`, otherwise it will be of type `jmespath`.\n","type":"object"},"form_fields":{"additionalProperties":{"type":"string"},"default":{},"description":"A collection of static form fields to be supplied in the request body, alongside the actual notification payload. The value of each field must be a string. For example, if the subscriptions has this property set to `{\"foo\" : \"bar\"}`, the corresponding notification HTTP request body will be\n```\n--2769baffc4f24cbc83ced26aa0c2f712 Content-Disposition: form-data; name=\"foo\"\nbar Content-Disposition: form-data; name=\"payload\"\n{\"transaction_id\": \"301c9079-3b20-4311-a131-bcda9b7f08ba\", \"subscription_id\": ... --2769baffc4f24cbc83ced26aa0c2f712--\n```\nSince the type of this property is `object`, multi-valued fields are not supported. This property is ignored unless `encoding` is `multipart/form-data`.\n","type":"object"},"hmac_key_id":{"description":"An optional key ID to use with `hmac_secret_key`.\n","type":"string"},"hmac_secret_key":{"description":"The key for signing requests to the subscriber's URL. The signature will be constructed according to https://tools.ietf.org/html/draft-cavage-http-signatures and transmitted in the HTTP `Authorization` header.\n","type":"string"},"jmespath_query":{"description":"An JMESPath query for restricting the set of bundles for which the subscriber is notified. The subscriber will only be notified for new bundles that match the given query. If `es_query` is specified, the subscription will be of type `elasticsearch`. If `es_query` is not present, the subscription will be of type `jmespath`\n","type":"string"},"method":{"default":"POST","description":"The HTTP request method to use when delivering a notification to the subscriber.","enum":["POST","PUT"]},"payload_form_field":{"default":"payload","description":"The name of the form field that will hold the notification payload when the request is made. If the default name of the payload field collides with that of a field in `form_fields`, this porperty can be used to rename the payload and avoid the collision. This property is ignored unless `encoding` is `multipart/form-data`.\n","type":"string"}},"required":["callback_url"],"type":"object"}}],"responses":{"201":{"description":"OK","schema":{"properties":{"uuid":{"description":"A RFC4122-compliant ID for the subscription.","pattern":"[A-Za-z0-9]{8}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{12}","type":"string"}},"required":["uuid"],"type":"object"}},"default":{"description":"Unexpected error","schema":{"allOf":[{"$ref":"#/definitions/Error"},{"properties":{"code":{"description":"Machine-readable error code.  The types of return values should not be changed lightly.","enum":["unhandled_exception","Forbidden","Unauthorized","OAuthResponseProblem","elasticsearch_error","invalid_attachment_expression","invalid_attachment_name","invalid_query_type","invalid_jmespath","unprocessable","read_only"],"type":"string"}},"required":["code"],"type":"object"}]}}},"security":[{"dcpAuth":[]}],"summary":"Create a event subscription."}},"/subscriptions/{uuid}":{"delete":{"description":"Delete a registered event subscription. The associated query will no longer trigger a callback if a matching document is added to the system.\n","parameters":[{"description":"A RFC4122-compliant ID for the subscription.","in":"path","name":"uuid","pattern":"[A-Za-z0-9]{8}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{12}","required":true,"type":"string"},{"description":"Replica to delete from.","enum":["aws","gcp"],"in":"query","name":"replica","required":true,"type":"string"},{"default":"elasticsearch","description":"type of subscriptions to fetch (elasticsearch or jmespath)","enum":["elasticsearch","jmespath"],"in":"query","name":"subscription_type","required":false,"type":"string"}],"responses":{"200":{"description":"OK","schema":{"properties":{"timeDeleted":{"description":"Timestamp of query subscription deletion in DSS_VERSION format.","format":"DSS_VERSION","type":"string"}},"required":["timeDeleted"],"type":"object"}},"default":{"description":"Unexpected error","schema":{"allOf":[{"$ref":"#/definitions/Error"},{"properties":{"code":{"description":"Machine-readable error code.  The types of return values should not be changed lightly.","enum":["unhandled_exception","Forbidden","Unauthorized","OAuthResponseProblem","not_found","read_only"],"type":"string"}},"required":["code"],"type":"object"}]}}},"security":[{"dcpAuth":[]}],"summary":"Delete an event subscription."},"get":{"description":"Given a subscription UUID, return the associated subscription.\n","parameters":[{"description":"A RFC4122-compliant ID for the subscription.","in":"path","name":"uuid","pattern":"[A-Za-z0-9]{8}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{12}","required":true,"type":"string"},{"description":"Replica to fetch from.","enum":["aws","gcp"],"in":"query","name":"replica","required":true,"type":"string"},{"default":"elasticsearch","description":"type of subscriptions to fetch (elasticsearch or jmespath)","enum":["elasticsearch","jmespath"],"in":"query","name":"subscription_type","required":false,"type":"string"}],"responses":{"200":{"description":"OK","schema":{"properties":{"subscription":{"$ref":"#/definitions/Subscription"}},"type":"object"}},"default":{"description":"Unexpected error","schema":{"allOf":[{"$ref":"#/definitions/Error"},{"properties":{"code":{"description":"Machine-readable error code.  The types of return values should not be changed lightly.","enum":["unhandled_exception","Forbidden","Unauthorized","OAuthResponseProblem","not_found"],"type":"string"}},"required":["code"],"type":"object"}]}}},"security":[{"dcpAuth":[]}],"summary":"Retrieve an event subscription given a UUID."}}},"produces":["application/json"],"schemes":["https"],"securityDefinitions":{"dcpAuth":{"authorizationUrl":"https://auth.data.humancellatlas.org/authorize","description":"The following claims must be present in the JWT: - 'https://auth.data.humancellatlas.org/group': the user group this user belongs. - 'iss': must be https://humancellatlas.auth0.com/ or a trusted google project. - 'aud': audience must match dss.dev.data.humancellatlas.org. - 'https://auth.data.humancellatlas.org/email': the email of the requester\n","flow":"implicit","scopes":{"email":"This scope value requests access to the email and email_verified Claims.","offline_access":"see http://openid.net/specs/openid-connect-core-1_0.html#OfflineAccessPrivacy","openid":"see http://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims"},"type":"oauth2"}},"swagger":"2.0"}
